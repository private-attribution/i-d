



Privacy Preserving Measurement                                 B. Savage
Internet-Draft                                                      Meta
Intended status: Standards Track                              M. Thomson
Expires: 6 January 2025                                          Mozilla
                                                             5 July 2024


Efficient Protocols for Binary Fields in the 3-Party Honest Majority MPC
                                Setting
                    draft-savage-ppm-3phm-mpc-latest

Abstract

   TODO

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at https://private-
   attribution.github.io/i-d/draft-savage-ppm-3phm-mpc.html.  Status
   information for this document may be found at
   https://datatracker.ietf.org/doc/draft-savage-ppm-3phm-mpc/.

   Discussion of this document takes place on the Privacy Preserving
   Measurement Working Group mailing list (mailto:ppm@ietf.org), which
   is archived at https://mailarchive.ietf.org/arch/browse/ppm/.
   Subscribe at https://www.ietf.org/mailman/listinfo/ppm/.

   Source for this draft and an issue tracker can be found at
   https://github.com/private-attribution/i-d.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 6 January 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  MPC Protocols in Binary Fields
   2.  Three-Party Honest Majority MPC
     2.1.  MPC Protocol Prerequisites
     2.2.  Fields and Rings
     2.3.  Secret Sharing
     2.4.  Identifying Shares and Parties
     2.5.  Reveal Protocol
     2.6.  Addition
   3.  Multiplication Protocol
   4.  Validation Protocol
     4.1.  Additive Attack
     4.2.  Malicious Security
     4.3.  Overview of the validation protocol
     4.4.  Distributed Zero-Knowledge Proofs
     4.5.  Distributed Zero Knowledge Proofs
     4.6.  Transforming into a large prime field
     4.7.  Validating a batch of multiplications
     4.8.  Overview of Recursive Proof Compression
     4.9.  Detailed Validation Algorithm
       4.9.1.  Selecting the Compression Factor
       4.9.2.  Producing Polynomials p(x) and q(x)
     4.10. Producing the zero knowledge proof
       4.10.1.  Masking the zero-knowledge proof
       4.10.2.  Checking that the proof says the right thing
       4.10.3.  Generating a random challenge
       4.10.4.  Recursive Proof
       4.10.5.  The Final Iteration
   5.  Conditions of Usage
     5.1.  Recommended Parameters
   6.  Performance Characteristics
   7.  Security Considerations
   8.  IANA Considerations
   9.  References
     9.1.  Normative References
     9.2.  Informative References
   Appendix A.  Acknowledgments
   Authors' Addresses

1.  Introduction

   Multiparty Computation (MPC) can perform generic computations over
   inputs that are never revealed to any single entity.  MPC executes an
   agreed function, revealing only the output of that function.

   This makes MPC well-suited to handling data that is sensitive or
   private.  MPC in a three-party honest majority setting, is broadly
   recognized as being extremely efficient:

   *  Addition and subtraction have zero communication cost and
      negligible computation cost.

   *  Multiplication is possible with low communication and computation
      complexity.

   *  Strong guarantees can be made about correctness and
      confidentiality, relying on only information-theoretic
      assumptions.

   This document describes the basic elements required to compute basic
   MPC circuits in this setting.  This includes the basic elements of
   the replicated secret sharing scheme that is used: generating shares,
   share addition, and revealing shared values.

   The bulk of the document describes a protocol for multiplication over
   a binary field.  The basic multiplication protocol scales linearly
   and involves 1 bit of communication per party.

   This basic multiplication protocol does not prevent an additive
   attack.  To deal with the additive attack, a batched validation
   protocol is used, which adds a sub-linear overhead.  This protocol
   comes with significant memory costs and slightly increased
   computational costs, but adds negligible communication overhead and
   latency when there are many multiplications to validate.

1.1.  MPC Protocols in Binary Fields

   This document describes a multiplication protocol that is specialized
   for use with binary fields; see Section 2.2.

   Composing binary operations into a complete MPC system has proven to
   be more efficient than alternatives using prime fields in a number of
   applications.  Some of the components in this document can be applied
   to rings or larger prime fields, but the validation process used here
   has been specialized for use with binary values.

2.  Three-Party Honest Majority MPC

   A three-party honest majority MPC system performs computations on
   secret-shared values using a replicated scheme where each party
   receives two out of three additive shares of input values.  Strong
   guarantees are provided regarding the confidentiality of inputs
   provided that no pair of parties reveals their shares to either of
   the other parties.

   The protocols described in this document depend on having three MPC
   parties execute them.  The protocols described here are secure with
   abort, even when one party is not honest.

   Concretely, this means that a single dishonest party cannot cause the
   value of inputs to be revealed.  Also, a single dishonest party
   cannot alter the output of any operation without detection.  The
   protocol is aborted if honest parties detect an error that might
   indicate the actions of a dishonest party.  This means that a
   dishonest party can disrupt the protocol

2.1.  MPC Protocol Prerequisites

   MPC parties require channels to each of the other parties that
   provide confidentiality, integrity and peer authentication.
   Mutually-authenticated TLS [RFC8446] provides the necessary
   capabilities, however, this document does not define how to arrange
   communication between parties; protocols that use these mechanisms
   need to define how communication between parties is established.

   The multiplication protocol described depends on shared randomness
   for efficiency.  The protocol depends on having a way for parties to
   pairwise agree on random values.  MPC parties can execute a coin toss
   protocol using the communication channel, however it is considerably
   more efficient to use pseudorandom secret sharing [PRSS] when there
   are a large number of multiplications.

   This section describes basic operations of secret sharing
   (Section 2.3), reveal protocol (Section 2.5), and addition
   (Section 2.6).  Multiplication is more involved and is the subject of
   subsequent sections (Section 3, Section 4).

2.2.  Fields and Rings

   The basic multiplication protocol described in Section 3 operates in
   any commutative ring, which will be referred to as simply a "ring".
   A ring is a group that defines addition and multiplication operations
   that are both associative and commutative.  A ring has an additive
   inverse for every element, which enables subtraction.  A ring
   contains a "zero" element that is an additive identity plus a "one"
   element that is a multiplicative identity.

   A simple realization of a ring is formed of integers modulo a chosen
   integer that is greater than 1.

   The validation protocol described in this document (see Section 4)
   uses a modulo 2 ring.  This ring is referred to throughput as a
   binary field as it is also a field and it contains two values: 0 and
   1.  Addition and multiplication in a binary field correspond to
   Boolean operations.  Addition in a binary field is equivalent to the
   Boolean exclusive OR (XOR) operation.  Multiplication in a binary
   field is equivalent to the Boolean AND operation.

   The security properties of the validation protocol depend on the use
   of a prime field of sufficient size.  Fields support the same
   operations as rings, adding multiplicative inversion of elements,
   which enables a division operation.  A prime field can be realized
   from integers modulo any prime.  The validation protocol integrates
   the projection of values in a binary field to a larger prime field,
   rather than requiring a separate conversion step.

2.3.  Secret Sharing

   Each input value (x) is split into three shares (x₁, x₂, x₃), such
   that x = x₁ + x₂ + x₃. Any method can be used, but the following
   process is typical:

   x₁ = random()
   x₂ = random()
   x₃ = x - x₁ - x₂

   Then, each party in the MPC receives a different set of two values.
   This document adopts the convention that P_1 receives (x₁, x₂), P_2
   receives (x₂, x₃), and P_3 receives (x₃, x₁).  From this sharing, no
   single party is able to construct the original value (x), but the
   values from any two parties include all three shares and can be used
   to reconstruct the original value.

   Some protocols might require that the parties construct a sharing of
   a value which is known to all the parties.  In that case, the value
   of x₁ is set to the known value, with x₂ and x₃ both set to zero.

2.4.  Identifying Shares and Parties

   This document identifies shares and parties by number.  Three parties
   are identified as P_1, P_2, and P_3.  The first, or left share, value
   held by each party is identified with the same subscript.  The other
   share, or right share, held by each is the next highest-numbered
   share (with x₁ being the next highest after x₃).  This is illustrated
   in Figure 1:

           x₂  .----.  x₁
          .---|  P₁  |---.
         /     `----'     \
    x₂  /                  \  x₁
    .----.                .----.
   |  P₂  |--------------|  P₃  |
    `----'  x₃        x₃  `----'

                        Figure 1: Parties and Shares

   Three parties are identified as P_1, P_2, and P_3.

   The three parties are logically placed in a ring, with higher
   numbered parties to the right of lower-numbered parties.  P_3 is
   placed to the left of P_1.  This means that if a protocol involves
   sending a value to the left, P_1 sends the value to P_3, P_2 sends to
   P_1, and P_3 sends to P_2.  The sending directions are illustrated in
   Figure 2.

   send                               send
   left:       .----.                 right:      .----.
          .-->|  P₁  |---.                   .---|  P₁  |<--.
         /     `----'     \                 /     `----'     \
        /                  v               v                  \
    .----.                .----.       .----.                .----.
   |  P₂  |<-------------|  P₃  |     |  P₂  |------------->|  P₃  |
    `----'                `----'       `----'                `----'

                  Figure 2: Parties and Sending Directions

   Protocols are often described in terms of the actions of a single
   party.  The party to the left of that party is P_(-) and the party to
   the right is P_(+).  Where necessary, the current party is identified
   as P_(=).

   The two shares that each party holds are referred to as "left" and
   "right" shares.  The "left" share is identified with a subscript of
   "-" (e.g., x_(-)); the numeric identifier for the left share at each
   party matches the identifier for that party, so the left share of x
   that P_1 holds is named x_1.  The right share is designated with a
   subscript of "+" (e.g., y_(+)); the numeric identifier for the right
   share is one higher than the identifier for the party, so the right
   share at P_3 is (also) x_1.

2.5.  Reveal Protocol

   The output of a protocol can be revealed by sending all share values
   to the entity that will receive the final result.  This entity can
   validate the consistency of the values it receives by ensuring that
   the replicated values it receives are identical.  That is, the value
   of x_1 received from P_1 is the same as the value of x_1 it receives
   from P_3 and so forth.  If the value of shares are inconsistent, the
   protocol fails.  After discarding these duplicated values, the
   revealed value is the sum of the shares that it receives.

   A value can be revealed by sending adjacent parties the one share
   value they do not have.  That is, P_1 sends x_1 to P_2 and x_2 to
   P_3; P_2 sends x_2 to P_3 and x_3 to P_(1;) P_3 sends x_3 to P_1 and
   x_1 to P_2.  Each party verifies that they receive the same value
   twice, and aborts if they do not.

   If the protocol is executed correctly, each party learns the revealed
   value, which is the sum of the two shares it holds, plus the share
   that was received.

   This basic reveal protocol requires that each party send and receive
   two elements.  More efficient protocols are possible, but these are
   not defined in this document.

2.6.  Addition

   Addition of two values in this setting is trivial and requires no
   communication between parties.  To add x to y, each party adds their
   shares.  That is, to compute z = x + y, each party separately
   computes the sum of the shares they hold:

   z₋ = x₋ + y₋
   z₊ = x₊ + y₊

   This produces shares of the sum without requiring communication.

   A similar process can be used for multiplication with a value that is
   known to all parties, negation, and subtraction.

      |  Note: Addition in a binary field is the same as subtraction and
      |  both are equivalent to the XOR operation.

3.  Multiplication Protocol

   The product of two shared values, x and y, is computed using the
   following process.

   Since x = x_1 + x_2 + x_3 and y = y_1 + y_2 + y_3 the product z = x *
   y can be expanded as:

   z = (x₁ + x₂ + x₃) \* (y₁ + y₂ + y₃)

   This can be illustrated with a 3 by 3 table (Table 1):

                   +=====+=========+=========+=========+
                   |     | y₁      | y₂      | y₃      |
                   +=====+=========+=========+=========+
                   | x_1 | x_1*y_1 | x_1*y_2 | x_1*y_3 |
                   +-----+---------+---------+---------+
                   | x_2 | x_2*y_1 | x_2*y_2 | x_2*y_3 |
                   +-----+---------+---------+---------+
                   | x_3 | x_3*y_1 | x_3*y_2 | x_3*y_3 |
                   +-----+---------+---------+---------+

                      Table 1: Multiplication by Parts

   To compute the product, each party locally computes the sum of three
   products as follows:

   z₋ = x₋·y₋ + x₋·y₊ + x₊·y₋

   To visualize this, Figure 3 shows cells labeled with the party
   responsible for computing that partial product:

           y₁     y₂     y₃            y₁     y₂     y₃
        +-------------+------+      +--------------------+
     x₁ |  P₁         |      |   x₁ |                    |
        |      +------+      |      |      +-------------+
     x₂ |      |             |   x₂ |      |  P₂         |
        +------+             |      |      |      +------+
     x₃ |                    |   x₃ |      |      |      |
        +--------------------+      +------+------+------+

         y₁     y₂     y₃
        +-------------+------+
     x₁ |             |  P₃  |
        |             +------+
     x₂ |                    |
        +------+      +------+
     x₃ |  P₃  |      |  P₃  |
        +------+------+------+

                     Figure 3: Multiplication by Party

   The result is a non-replicated sharing of the result z =
   z<sub>1</sub> + z₂ + z₃.

   To reach the desired state where parties each have replicated shares
   of z, each party needs to send its share, z_(-), to the party to its
   left.

   Unfortunately, each party cannot simply send this value to another
   party, as this would allow the recipient to reconstruct the full
   input values, x and y, using z_(-).  To prevent this, the value of
   z_(-) is masked with a uniformly distributed random mask that is
   unknown to party P_(-).

   Using a source of shared randomness (such as [PRSS]), each pair of
   helpers generates a uniformly distributed random value known only to
   the two of them.  Let r_(-) denote the left value (known to P_(-))
   and r_(+) be the right value (known to P_(+)).

   Each party uses r_(-) and r_(+) to create a masked value of z_(-) as
   follows:

   z₋ = x₋·y₋ + x₋·y₊ + x₊·y₋ + r₋ - r₊

   These three mask values sum to zero, so this masking does not alter
   the result.  Importantly, the value of r_(+) is not known to P_(-),
   which ensures that z_(-) cannot be used by P_(-) to recover x or y.
   Thus, z_(-) is safe to send to P_(-).

   Upon receiving a value from its right — which the recipient names
   z_(+) — each helper is now in possession of two-of-three shares,
   (z_(-), z_(+)), which is a replicated secret sharing of the product
   of x and y.

4.  Validation Protocol

   The basic multiplication protocol in Section 3 only offers "semi-
   honest security".  It is "secure up to an additive attack".
   Validating multiplications allows any additive attack to be detected,
   ensuring that a protocol is aborted before any result is produced
   that might compromise the confidentiality of inputs.

4.1.  Additive Attack

   By "additive attack", we mean that instead of sending the value
   z_(-), a corrupted party could instead send z_(-) + a.  In the
   context of boolean circuits, the only possible additive attack is to
   add 1.

   The multiplication protocol described does not prevent this.  Since
   the value z_(-) is randomly distributed, the party (P_(-)) that
   receives this value cannot tell if an additive attack has been
   applied.

   While an additive attack does not result in information about the
   inputs being revealed, it corrupts the results.  If a protocol
   depends on revealing certain values, this sort of corruption could be
   used to reveal information that might not otherwise be revealed.

   For example, if the parties were computing a function that erases a
   value unless it has reached some minimum such as:

   if total_count > 1000:
       reveal(total_count)
   else:
       reveal(0)

   If a corrupted helper wanted to reveal a total_count that was less
   than 1000, it could add 1 to the final multiplication used to compute
   the condition total_count > 1000.  The result is that values below
   the minimum are revealed (and values above the minimum are erased),
   violating the conditions on the protocol.

4.2.  Malicious Security

   Before any values are revealed, the parties perform a validation
   protocol.  This protocol confirms that all of the multiplications
   performed were performed correctly.  That is, that no additive attack
   was applied by any party.

   If this validation protocol fails, the parties abort the protocol and
   no values are revealed.  All parties destroy the shares they hold.

4.3.  Overview of the validation protocol

   Each of the parties, P_(=), produces a "Zero Knowledge Proof" (ZKP)
   that proves all of the multiplications it performed were done
   correctly.  The other two parties, P_(-) and P_(+), act as
   "verifiers" and validate this zero knowledge proof.

   When operating in a boolean field, if P_(=) followed the protocol
   correctly, this is how they would compute z_(-)

   z₋ = x₋·y₋ ⊕ x₋·y₊ ⊕ x₊·y₋ ⊕ r₋ ⊕ r₊

   So the expression:

   x₋·y₋ ⊕ x₋·y₊ ⊕ x₊·y₋ ⊕ r₋ ⊕ r₊ ⊕ z₋ = 0

   will hold true if the protocol was followed correctly, but will equal
   *_one_* if there was an additive attack.

   By computing this quantity in a large prime field (not a boolean
   field), and then summing across all of the multiplications in a
   batch, we can compute the total number of times an additive attack
   was applied.  So long as the number of multiplication in a validation
   batch is smaller than the size of the prime field, this approach will
   detect any deviation from the protocol.

   For this protocol, the parties will use the field of integers mod p,
   where p is the Mersenne prime 2^61-1.  Other primes could be used,
   but this value provides good security margins for a large number of
   multiplications.  It also provides several opportunities for
   optimization on 64-bit hardware.

4.4.  Distributed Zero-Knowledge Proofs

   The prover needs to prove that for each multiplication in a batch:

   x₋·y₋ ⊕ x₋·y₊ ⊕ x₊·y₋ ⊕ r₋ ⊕ r₊ ⊕ z₋ = 0

   The verifier on the left, P_(-), knows the values of:

   *  y_(-)

   *  x_(-)

   *  r_(-)

   *  z_(-)

   The verifier on the right, P_(+), knows the values of:

   *  x_(+)

   *  y_(+)

   *  r_(+)

   This means that the "prover", P_(=), does not need to send any of
   these values to the verifiers.  Verifiers use information they
   already have to validate the proof.

   Since the two verifiers possess all of this information distributed
   amongst themselves, this approach is referred to as "Distributed Zero
   Knowledge Proofs".

4.5.  Distributed Zero Knowledge Proofs

   [FLPCP] introduces an elegant tool, which only requires O(logN)
   communication, for proving expressions of the form:

   sum(i=0..n, uᵢ · vᵢ) = t

   In the setting where the Prover (P_(=)) and the left verifier (P_(-))
   both are in possession of the n-vector u, the Prover (P_(=)) and the
   other verifier (P_(+)) are in possession of the n-vector v, and the
   verifiers P_(-) and P_(+) hold t_(-) and t_(+) respectively and
   t<sub>-</sub> + t₊ = t.

   However, the security of this protocol requires the vector elements u
   and v to be members of a large field.  So the first step of the
   validation protocol is to take a batch of multiplications, and
   convert them into a dot product of vectors with elements in a large
   field.

4.6.  Transforming into a large prime field

   [BINARY] describes how to apply [FLPCP] efficiently for binary
   fields.  When binary values are directly lifted into a large field,
   the XOR operation can be computed with the expression:

   f(x, y) = x ⊕ y
           = x + y - 2·x·y
           = x·(1 - 2·y) + y

   Using this relation, the expression that must be proven can be
   converted into a dot-product of two vectors, one of which is known to
   both P_(=) and P_(-), the other being known to both P_(=) and P_(+).

   Rearranging terms:

   x₋·y₊ ⊕ (x₋·y₋ ⊕ z₋ ⊕ r₋ ) ⊕ x₊·y₋ ⊕ r₊ = 0

   Define:

   e₋ = x₋·y₋ ⊕ z₋ ⊕ r₋

   Then:

   (x₋·y₊ ⊕ e₋ ) ⊕ (x₊·y₋ ⊕ r₊) = 0

   Using: x ⊕ y = x·(1 - 2·y) + y

   (x₋·y₊·(1 - 2e₋) + e₋) ⊕ (x₊·y₋·(1 - 2r₊) + r₊) = 0

   Using: x ⊕ y = x + y - 2·x·y

   (x₋·y₊·(1 - 2e₋) + e₋)
   + (x₊·y₋·(1 - 2r₊) + r₊)
   - 2(x₋·y₊·(1 - 2e₋) + e₋)(x₊·y₋·(1 - 2r₊) + r₊) = 0

   Distributing Terms:

   x₋·(1 - 2e₋)·y₊ + e₋
   + y₋·x₊·(1 - 2r₊) + r₊
   - 2x₋·y₋·(1 - 2e₋)·y₊·x₊·(1 - 2r₊) - 2x₋·(1 - 2e₋)·y₊·r₊ - 2e₋·y₋·x₊·(1 - 2r₊) - 2e₋·r₊ = 0

   Rearranging terms, and subtracting 1/2 from both sides:

   - 2x₋·y₋·(1 - 2e₋)·y₊·x₊·(1 - 2r₊)
   + y₋·x₊·(1 - 2r₊) - 2e₋·y₋·x₊·(1 - 2r₊)
   + x₋·(1 - 2e₋)·y₊ - 2x₋·(1 - 2e₋)·y₊·r₊
   + e₋ - 2e₋·r₊ + r₊ - ½ = - ½

   Factoring allows this to be written as an expression with four terms,
   each with a component taken from the left (which we will label g) and
   a component from the right (which we will label h):

   [-2x₋·y₋·(1 - 2e₋)] · [y₊·x₊·(1 - 2r₊)]
   + [y₋(1 - 2e₋)] · [x₊·(1 - 2r₊)]
   + [x₋·(1 - 2e₋)] · [y₊(1 - 2r₊)]
   + [-½(1 - 2e₋)] · [(1 - 2r₊)] = -½

   Renaming terms as new variables, the result is the dot product of two
   four dimensional vectors, g and h:

   g₁·h₁ + g₂·h₂ + g₃·h₃ + g₄·h₄ = -½

   Or alternatively:

   sum(i=1..4, gᵢ·hᵢ) = -½

   Where P_(=) and P_(+) both compute hᵢ as follows:

   h₁ = y₊·x₊·(1 - 2·r₊)
   h₂ = x₊·(1 - 2·r₊)
   h₃ = y₊·(1 - 2·r₊)
   h₄ = 1 − 2·r₊

   And P_(=) and P_(-) both compute gᵢ as follows:

   g₁ = -2·x₋·y₋·(1 - 2·e₋ )
   g₂ = y₋·(1 - 2·e₋ )
   g₃ = x₋·(1 - 2·e₋ )
   g₄ = -½(1 - 2·e₋)

   And where:

   e₋ = x₋ · y₋ ⊕ z₋ ⊕ r₋

   In this field, the negative inverse of two (-½) is
   1,152,921,504,606,846,975.

4.7.  Validating a batch of multiplications

   Each multiplication therefore produces two vectors of length 4.  To
   validate a batch of m multiplications, the Prover (P_(=)), uses this
   approach to produce two vectors of length 4m.

   The Prover P_(=) and verifier P_(-) both compute the vector u

   u = (g₁⁽¹⁾, g₂⁽¹⁾, g₃⁽¹⁾, g₄⁽¹⁾, …, g₁⁽ᵐ⁾, g₂⁽ᵐ⁾, g₃⁽ᵐ⁾, g₄⁽ᵐ⁾)

   The Prover P_(=) and verifier P_(+) both compute the vector v

   v = (h₁⁽¹⁾, h₂⁽¹⁾, h₃⁽¹⁾, h₄⁽¹⁾, …, h₁⁽ᵐ⁾, h₂⁽ᵐ⁾, h₃⁽ᵐ⁾, h₄⁽ᵐ⁾)

   If no additive attacks were applied, the dot product of these two
   vectors should be:

   u · v = -m/2

4.8.  Overview of Recursive Proof Compression

   Now that we have expressed the work of the prover as a simple dot
   product of two vectors of large field elements, we can use a
   recursive approach to prove this expression with O(logN)
   communication.

   The process is iterative, where at each stage there is a pair of
   vectors, u and v, and a target, t, where the goal is to prove that u
   · v = t.  The values of u and v start as described in Section 4.7;
   with t initially set to a value of -m/2.

   At each iteration:

   1.  Select a compression factor L.

   2.  Chunk the vectors u and v into s segments of length L.

       1.  Each chunk of u uniquely defines a polynomial of degree L - 1
           which are named pᵢ(x), indexed by i∊[0..s).

       2.  Each chunk of v uniquely defines a polynomial of degree L - 1
           which are named qᵢ(x), indexed by i.

   3.  The polynomial G(x) is defined as: sum(i=0..s, pᵢ(x) · qᵢ(x))

       This polynomial G(x) is equivalent to u · v so the goal becomes
       proving that sum(i=0..L-1, G(i)) = t.

       In the first iteration, the target value t is known by all
       parties to be -m/2.  In subsequent iterations the target value
       will be different.

       1.  The prover will compute the value of 2L - 1 points on G(x),
           the minimal number required to uniquely define it.

       2.  These 2L - 1 points are split into two additive secret-shares
           G(x)₋ and G(x)₊ and sent to the verifiers P_(-) and P_(+),
           respectively.  These shares form the distributed zero-
           knowledge proof.

       3.  The verifiers verify the proposition using their shares by
           computing b₋ = t₋ - sum(i=0..L-1, G(x)₋) and b₊ = t₊ -
           sum(i=0..L-1, G(x)₊).  They send each other the value they
           compute and confirm that b<sub>-</sub> + b₊ = 0.  If this
           test fails, the entire protocol is aborted.

   4.  At this point, the prover could have produced values for
       G(0..L-1) that pass this test even if they had performed an
       additive attack.  The proof needs to be validated by confirming
       that G(r) = sum(i=0..s, p<sub>i</sub>(r) · qᵢ(r)) for a randomly
       selected challenge point r.  As long as the prover cannot control
       the choice of r, the likelihood that the prover is dishonest is
       inversely proportional to the field size.

       1.  If we define two new vectors u’ = <p<sub>0</sub>(r), …,
           p<sub>s-1</sub>(r)>, and v’ = <q<sub>0</sub>(r), …,
           q<sub>s-1</sub>(r)>, then we can rewrite the statement that
           needs to be proven as: u’ · v’ = G(r).  This is of the same
           form as the original statement, but with the new vectors u’
           and v’ having length L times shorter than the original
           vectors.

       2.  Each of the verifiers can use the values of G(x) that they
           have received to compute a share of G(r) using Lagrange
           interpolation.  These shares become their share of a new
           value for t.

       3.  The Fiat-Shamir heuristic can be used to generate r by
           hashing the distributed zero knowledge proof.  This
           transforms this protocol from a multi-round interactive
           protocol into a constant round protocol.

   5.  The vectors u and v are replaced by u’ and v’, the value of t is
       set to G(r), and the next iteration is started.

   The recursion ends when the vectors u and v have length less than L.
   The verifiers validate the soundness of the final iteration of the
   proof in a simpler, more direct way; see Section 4.10.5.

4.9.  Detailed Validation Algorithm

4.9.1.  Selecting the Compression Factor

   For the first iteration, the parties will use a compression factor
   (L) of 32.  In all subsequent rounds they will use a compression
   factor of 8.

   Note: A larger value for L increases the compression factor, which
   reduces the overall communication cost.  However, because the
   computation of the proof requires Lagrange interpolation (which is
   O(L^2) computation), a larger compression factor quickly becomes
   expensive.  A slightly larger compression factor on the first round
   is possible because there are only a small number of possible input
   values, so the work can be reduced with the use of lookup tables if
   necessary.

4.9.2.  Producing Polynomials p(x) and q(x)

   The prover (P_(=)) and the verifier P_(-), chunk the vector u into s
   chunks of length L.

   chunk 0: <u₀, u₁, …, u<sub>L-1</sub>>
   chunk 1: <u<sub>L</sub>, u<sub>L+1</sub>, …, u<sub>2L-1</sub>>
   …
   chunk s-1: <u<sub>(s-1)L</sub>, u<sub>(s-1)L+1</sub>, …, u<sub>sL-1</sub>>

   If the length of u is not divisible by L, then the final chunk will
   be padded with zeros.

   In the first iteration there will be s = ceil(4m / L) chunks, as the
   original vectors u and v have length 4m.  In subsequent iterations
   there will be fewer chunks.

   They will interpret each chunk (i) as L points lying on a polynomial,
   p_i(x) of degree L - 1, corresponding to the x coordinates 0, 1, …,
   L-1, that is to say they will interpret them as p_i(0), p_i(1), …,
   p_i(L-1).

   The Prover (P_(=)) and verifier (P_(-)) can find the value of p_i(x)
   for any other value of x by using Lagrange interpolation.

   The Prover will use Lagrange interpolation to compute the value of
   p_i(L), p_i(L+1), …, p_i(2L-2).

   The same process is applied for the vector v.

   The Prover (P_(=)) and the verifier P_(+), will chunk the vector v
   into s chunks of length L.

   chunk 0: <v₀, v₁, …, v<sub>L-1</sub>>
   chunk 1: <v<sub>L</sub>, v<sub>L+1</sub>, …, v<sub>2L-1</sub>>
   …
   chunk s-1: <v<sub>(s-1)L</sub>, v<sub>(s-1)L+1</sub>, …, v<sub>sL-1</sub>>

   As before, if the length of v is not a multiple of L, the final chunk
   will be padded with zeros.

   They will interpret each chunk as L points lying on a polynomial,
   q_i(x), having degree L - 1.  Where the x coordinates are 0, 1, …,
   L-1, which is to say they will interpret these points as q_i(0),
   q_i(1), …, q_i(L-1).

   The Prover (P_(=)) and verifier P_(+) can find the value of q_i(x)
   for any other value of x by using Lagrange interpolation.

   The Prover will use Lagrange interpolation to compute the value of
   q_i(L), q_i(L+1), …, q_i(2L-2).

4.10.  Producing the zero knowledge proof

   In order to prove that u · v = t, the prover will compute the value
   of 2L - 1 points on the polynomial G(x), which is defined as:

   G(x) = sum(i=1..s, p_i(x) · q_i(x))

   The prover computes the values of G(0), G(1), …, G(2L-2) by
   incrementally aggregating the products of p_i(0), p_i(1), …, p_i(2L-
   21) and q_i(L), q_i(L+1), …, q_i(2L-2), it computes for each chunk
   (i).

   These 2L - 1 points on the polynomial G(x) constitute the zero-
   knowledge proof that u · v = t.

   An equivalent method of proving u · v = t, is to show that
   sum(i=0..L-1, G(i)) = t

4.10.1.  Masking the zero-knowledge proof

   The Prover (P_(=)), cannot simply send this zero-knowledge proof to
   the verifiers, as doing so would release private information.
   Instead, the prover can produce a two-part additive secret-sharing of
   these 2L - 1 points, sending one share to each verifier.

   The Prover (P_(=)) and the right verifier (P_(+)) will generate one
   share using their shared randomness.  We will denote this share
   G(x)_(+).  This requires no communication.

   The Prover (P_(=)) will compute the other share via subtraction, and
   will send it to the left verifier (P_(-)).  Transmitting this share
   G(x)_(-), will require sending 2L - 1 field values, which will
   require 8 bytes per field value as we are using Mersenne prime 2^61-1
   for our prime field.

4.10.2.  Checking that the proof says the right thing

   To check that:

   sum(i=0..L-1, G(i)) = t

   The left verifier P_(-) will compute:

   b_(-) = t_(-) - sum(i=0..L-1, G(i)_(-))

   The right verifier P+ will compute:

   b_(+) = t_(+) - sum(i=0..L-1, G(i)_(+))

   The two verifiers will reveal these values b_(-) and b_(+) to one
   another, so that each can reconstruct the full sum:

   b = b_(-) + b_(+)

   They will confirm that b = 0.  If it does not, the parties abort and
   destroy their shares.

4.10.3.  Generating a random challenge

   Now that the verifiers have confirmed that the proof says that there
   was no additive attack, they need to validate that this was indeed a
   legitimate zero-knowledge proof, and not a bogus one that is
   disconnected from the actual work the prover did.

   To demonstrate that this zero knowledge proof is sound, it suffices
   to check that G(r) is correct, for a random field element r, chosen
   from the range [L, p).  In other words, it cannot be in the range [0,
   L).

   To minimize the rounds of communication, instead of having the
   verifiers select this random point, we utilize the Fiat-Shamir
   transformation to produce a constant-round proof system.

   The Prover (P_(=)) will hash the zero-knowledge proof shares it has
   generated onto a field element as follows:

   commitment = SHA256(
     concat(
       SHA256([G(x)]₋),
       SHA256([G(x)]₊)
     )
   )
   r = (bytes2int(commitment[..16]) % (prime - L)) + L

   This computation does not use the entire output of the hash function,
   just enough to ensure that the value of r has minimal bias.  For
   SHA-256 and a prime field modulo 2^61-1, the bias is in the order of
   2^-67, which is negligible.

   The verifiers generate the same point r independently.  Each verifier
   only has access to one set of shares from G(x) so they each compute a
   hash of the shares they have.  They then send that hash to each
   other, after which they can compute the full hash value.

   Note that one verifier does not need to receive their shares of G(x)
   from the prover, so they are able to compute their hash before even
   starting any computation.

   Consequently, though each round depends on communication, the total
   latency is two rounds.  In the first, the prover sends shares of G(x)
   to the first verifier.  Concurrently, the second verifier sends a
   hash of their shares to the first verifier.  In the second round, the
   first verifier sends a hash of their shares to the second verifier.

4.10.4.  Recursive Proof

   So the prover has to prove that G(r) is correct for this random
   challenge.

   Recall the definition of G(x):

   G(x) = sum(i=0..s, pᵢ(x) · qᵢ(x))

   So this amounts to proving that:

   u’ · v’ = G(r)

   Where:

   u’ = <p₀(r), p₁(r), …>
   v’ = <q₀(r), q₁(r), …>

   Note that this is a problem of exactly the same form as the original
   problem, except that the length of u’ and v’ is now a factor of L
   shorter than the original length of u and v.

   The Prover (P_(=)) and verifier P_(-) use Lagrange interpolation to
   compute the value of p_i(r) for all (i) in the range 0..s and set
   this as the new vector u’.

   Similarly, the Prover (P_(=)) and verifier P_(+) use Lagrange
   interpolation to compute the value of q_i(r) for all (i) in the range
   0..s and set this as the new vector v’.

4.10.5.  The Final Iteration

   The proof proceeds recursively until the length of the vectors u and
   v are strictly less than the compression factor L.

   Next, the Prover (P_(=)) and left verifier P_(-) will generate a
   random field value p_mask using PRSS.  Similarly, the Prover (P_(=))
   and right verifier P_(+) will generate a random field value q_mask
   using PRSS.

   The Prover (P_(=)) and left verifier P_(-) move u_0 to index L - 1.
   No data will be lost as the length of u is strictly less than L.
   Then they place the value p_mask at index 0.

   The Prover (P_(=)) and right verifier P_(+) move v_0 to index L - 1
   and place the value q_mask at index 0.

   The Prover will still generate a zero knowledge proof exactly as
   before, but the validation of soundness of this proof will proceed
   differently.

   Firstly, when the verifiers compute their shares of b, they must skip
   the random weights.

   So in the final iteration the left verifier P_(-) computes:

   b₋ = t₋ - sum(i=1..L-1, G(i)₋)

   And the right verifier P_(+) computes:

   b₊ = t₊ - sum(i=1,L-1, G(i)₊)

   The second difference is the way the verifiers validate the soundness
   of the zero knowledge proof.  In the final iteration the verifier
   P_(-) computes p_0(r) and G(r)_(-), while verifier P_(+) computes
   q_0(r) and G(r)_(+).  Then the verifiers reveal all of these values
   to one another, so that they can both directly check that:

G(r)<sub>-</sub> + G(r)<sub>+</sub> = p<sub>0</sub>(r) · q<sub>0</sub>(r)

   This is why the random masks were necessary in the final iteration.
   Those ensure that none of the values p_0(r), q_0(r), G(r)_(-), or
   G(r)_(+) reveal any private information.

5.  Conditions of Usage

   This protocol requires integration into a larger protocol, which will
   need to:

   *  set or negotiate parameters,

   *  provide communication channels,

   *  agree on shared secrets, and

   *  arrange the multiplications that are to be validated into batches.

5.1.  Recommended Parameters

   This document recommends several parameters, which are used in the
   security analysis.  Alternative parameters can be used, provided that
   they meet the stated requirements.

   For shared secrets, pseudorandom secret sharing [PRSS] is used.  For
   PRSS parameters, HPKE [RFC9180] with DHKEM(X25519, HKDF-SHA256),
   HKDF-SHA256, and AES-128-GCM is RECOMMENDED, with the same KDF being
   used for PRSS and AES-128 as the PRP.

   For validation, the prime field used is modulo the Mersenne prime
   2^61-1 validation.  Any sufficiently large prime can be used; see
   TODO/below for an analysis of the batch size requirements and
   security properties that can be obtained by using this particular
   prime.

   The Fiat-Shamir transform Section 4.10.3 used in the validation
   proofs can use SHA-256.  However, any preimage and collision-
   resistant hash function can be used provided that it has a enough
   output entropy to avoid bias in the selected field value.

6.  Performance Characteristics

   TODO

   *  Communication - number of bits sent/received

   *  Computation - how many times you invoke PRSS

   *  Vectorization - why it is useful and good

   *  How to multiply in parallel - sending and receiving, stalling,
      etc…

   *  Memory requirements

      -  Compression factor and choice

      -  Trade-offs - time/memory (factor of 64 during generation of r,
         for Fiat-Shamir version)

   *  Multiple rounds or Fiat-Shamir

7.  Security Considerations

   TODO

   *  Parameter choice and security margins

      -  Talk about trade-off between attack success probability and
         prime size.

      -  Show equation for how many bits of security you get when
         validating N multiplications

   *  You can’t just use the multiplication protocol without the
      validation protocol due to the additive attack (explain why)

   *  Communication security (authentication)

   *  Constant time and implications thereof

   *  Fiat-Shamir vs more rounds

8.  IANA Considerations

   This document has no IANA considerations.

9.  References

9.1.  Normative References

   [PRSS]     Thomson, M. and B. Savage, "High Performance Pseudorandom
              Secret Sharing (PRSS)", Work in Progress, Internet-Draft,
              draft-thomson-ppm-prss, July 2024,
              <https://datatracker.ietf.org/doc/html/draft-thomson-ppm-
              prss>.

9.2.  Informative References

   [BINARY]   Li, Y., Duan, Y., Huang, Z., Hong, C., Zhang, C., and Y.
              Song, "Efficient 3PC for binary circuits with application
              to maliciously-secure DNN inference", USENIX Association,
              Proceedings of the 32nd USENIX Conference on Security
              Symposium pp. 5377–5394, ISBN 978-1-939133-37-3, August
              2023.

   [FLPCP]    Boneh, D., Boyle, E., Corrigan-Gibbs, H., Gilboa, N., and
              Y. Ishai, "Zero-Knowledge Proofs on Secret-Shared Data via
              Fully Linear PCPs", Springer International Publishing,
              Advances in Cryptology – CRYPTO 2019 pp. 67-97,
              DOI 10.1007/978-3-030-26954-8_3, ISBN ["9783030269531",
              "9783030269548"], 2019,
              <https://doi.org/10.1007/978-3-030-26954-8_3>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/rfc/rfc8446>.

   [RFC9180]  Barnes, R., Bhargavan, K., Lipp, B., and C. Wood, "Hybrid
              Public Key Encryption", RFC 9180, DOI 10.17487/RFC9180,
              February 2022, <https://www.rfc-editor.org/rfc/rfc9180>.

Appendix A.  Acknowledgments

   This work is a direct implementation of the protocols described in
   [BINARY], which builds on a lot of prior academic work on MPC.

Authors' Addresses

   Ben Savage
   Meta
   Email: btsavage@meta.com


   Martin Thomson
   Mozilla
   Email: mt@lowentropy.net
